<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Collect Cubes — Simple 3D HTML Game</title>
  <style>
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    #game{width:100vw;height:100vh;display:block;overflow:hidden;}
    .ui{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.45);color:white;padding:10px;border-radius:8px}
    .ui small{display:block;color:#ddd}
    .controls{position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.45);color:white;padding:10px;border-radius:8px;text-align:right}
    button{background:#1e90ff;color:white;border:none;padding:8px 12px;border-radius:6px;cursor:pointer}
    button:disabled{opacity:0.5}
    .footer{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.35);color:#eee;padding:8px;border-radius:8px}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="ui">
    <div>Score: <span id="score">0</span></div>
    <small id="message">Collect all cubes before time runs out!</small>
  </div>
  <div class="controls">
    <div>Time: <span id="time">60</span>s</div>
    <div style="margin-top:8px">
      <button id="start">Start</button>
      <button id="restart" disabled>Restart</button>
    </div>
  </div>
  <div class="footer">Controls: WASD / Arrow keys — Jump: Space — Camera: Drag</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';

// ---------- Basic variables ----------
const canvas = document.getElementById('game');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.shadowMap.enabled = true;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 12, 18);

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 2, 0);
controls.enableDamping = true;
controls.maxPolarAngle = Math.PI/2 - 0.05;

// Resize handling
function onResize(){
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', onResize);
onResize();

// ---------- Lights ----------
const hemi = new THREE.HemisphereLight(0xffffff, 0x444466, 0.9);
hemi.position.set(0,30,0);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(5,20,10);
dir.castShadow = true;
dir.shadow.mapSize.set(1024,1024);
scene.add(dir);

// ---------- Ground ----------
const groundGeo = new THREE.PlaneGeometry(200,200);
const groundMat = new THREE.MeshStandardMaterial({color:0x2a6f3a});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// ---------- Player ----------
const player = new THREE.Mesh(
  new THREE.SphereGeometry(1, 24, 24),
  new THREE.MeshStandardMaterial({color:0xffaa00, metalness:0.2, roughness:0.6})
);
player.castShadow = true;
player.position.set(0,1,0);
scene.add(player);

let velocity = new THREE.Vector3();
let onGround = true;

// ---------- Obstacles & Collectibles ----------
const cubes = [];
const obstacles = [];
const cubeCount = 12; // change to increase difficulty

const cubeGeo = new THREE.BoxGeometry(1.6,1.6,1.6);
const cubeMat = new THREE.MeshStandardMaterial({color:0x00aaff});

for(let i=0;i<cubeCount;i++){
  const c = new THREE.Mesh(cubeGeo, cubeMat.clone());
  c.material.emissive = new THREE.Color(0x002244);
  c.position.set((Math.random()-0.5)*50, 0.8, (Math.random()-0.5)*50);
  c.userData.collected = false;
  c.castShadow = true;
  scene.add(c);
  cubes.push(c);
}

// moving obstacles (rotating columns)
for(let i=0;i<6;i++){
  const o = new THREE.Mesh(
    new THREE.CylinderGeometry(0.5,0.5,4,16),
    new THREE.MeshStandardMaterial({color:0x884444})
  );
  o.position.set((Math.random()-0.5)*60,2,(Math.random()-0.5)*60);
  o.castShadow = true;
  scene.add(o);
  obstacles.push(o);
}

// ---------- UI & Game state ----------
let score = 0;
let timeLeft = 60; // seconds
let running = false;
let lastTime = performance.now();

const scoreEl = document.getElementById('score');
const timeEl = document.getElementById('time');
const msgEl = document.getElementById('message');
const startBtn = document.getElementById('start');
const restartBtn = document.getElementById('restart');

startBtn.addEventListener('click', startGame);
restartBtn.addEventListener('click', resetGame);

function startGame(){
  if(running) return;
  running = true;
  startBtn.disabled = true;
  restartBtn.disabled = false;
  msgEl.textContent = 'Collect all cubes!';
  score = 0; scoreEl.textContent = score;
  timeLeft = 60; timeEl.textContent = timeLeft;
  // randomize cubes
  cubes.forEach(c=>{ c.position.set((Math.random()-0.5)*50,0.8,(Math.random()-0.5)*50); c.userData.collected=false; c.visible=true; });
}

function resetGame(){
  running = false;
  startBtn.disabled = false;
  restartBtn.disabled = true;
  msgEl.textContent = 'Press Start to play again.';
  score = 0; scoreEl.textContent = score;
  timeLeft = 60; timeEl.textContent = timeLeft;
  player.position.set(0,1,0); velocity.set(0,0,0);
}

resetGame();

// ---------- Input ----------
const keys = {};
window.addEventListener('keydown', (e) => { keys[e.code] = true; if(e.code==='Space') e.preventDefault();});
window.addEventListener('keyup', (e) => { keys[e.code] = false; });

// ---------- Simple collision helpers ----------
function collectCheck(){
  for(const c of cubes){
    if(c.userData.collected) continue;
    const d = c.position.distanceTo(player.position);
    if(d < 2.1){
      c.userData.collected = true;
      c.visible = false;
      score += 1;
      scoreEl.textContent = score;
      // small reward jump
      velocity.y = 6;
      if(score === cubes.length){
        running = false;
        msgEl.textContent = 'You win! All cubes collected.';
        startBtn.disabled = false;
        restartBtn.disabled = true;
      }
    }
  }
}

function obstacleCheck(){
  for(const o of obstacles){
    const d = o.position.distanceTo(player.position);
    if(d < 2){
      // knockback
      const knock = player.position.clone().sub(o.position).setY(0).normalize().multiplyScalar(6);
      velocity.add(knock);
    }
  }
}

// ---------- Main loop ----------
function animate(now){
  requestAnimationFrame(animate);
  const dt = Math.min((now - lastTime)/1000, 0.05);
  lastTime = now;

  // controls & physics only while running
  if(running){
    // timer
    timeLeft -= dt;
    if(timeLeft <= 0){
      timeLeft = 0; running = false; msgEl.textContent='Time Up!'; startBtn.disabled = false; restartBtn.disabled = false;
    }
    timeEl.textContent = Math.ceil(timeLeft);

    // obstacles move
    for(let i=0;i<obstacles.length;i++){
      const o = obstacles[i];
      o.rotation.y += 0.8*dt*(i%3+1);
      o.position.x += Math.sin(now*0.0005 + i)*dt*0.5;
    }

    // input
    const dir = new THREE.Vector3();
    if(keys['KeyW'] || keys['ArrowUp']) dir.z -= 1;
    if(keys['KeyS'] || keys['ArrowDown']) dir.z += 1;
    if(keys['KeyA'] || keys['ArrowLeft']) dir.x -= 1;
    if(keys['KeyD'] || keys['ArrowRight']) dir.x += 1;
    dir.normalize();

    // move relative to camera forward
    if(dir.lengthSq()>0){
      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize();
      const camRight = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), camDir).normalize();
      const move = camDir.multiplyScalar(-dir.z).add(camRight.multiplyScalar(dir.x));
      move.normalize().multiplyScalar(10*dt);
      player.position.add(move);
    }

    // jump
    if((keys['Space'] || keys['KeyX']) && onGround){ velocity.y = 8; onGround=false; }

    // apply gravity
    velocity.y -= 20 * dt;
    player.position.y += velocity.y * dt;
    if(player.position.y <= 1){ player.position.y = 1; velocity.y = 0; onGround = true; }

    // simple world bounds
    player.position.x = THREE.MathUtils.clamp(player.position.x, -95, 95);
    player.position.z = THREE.MathUtils.clamp(player.position.z, -95, 95);

    // checks
    collectCheck();
    obstacleCheck();
  }

  // camera follows player smoothly
  const camTarget = new THREE.Vector3().copy(player.position).add(new THREE.Vector3(0,2,0));
  controls.target.lerp(camTarget, 0.08);
  controls.update();

  renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// ---------- Helpful tips: keyboard focus ----------
// Click the canvas to allow keyboard input on some browsers
canvas.addEventListener('click', ()=>{ canvas.focus(); });

// End of module
</script>
</body>
</html>

